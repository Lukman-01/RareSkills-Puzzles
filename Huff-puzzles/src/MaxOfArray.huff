/** 
 *  MAX_OF_ARRAY HUFF EXERCISE
 *  
 *  In this task, Given an abi encoded array of uint256, return its maximum value. Revert if the array is empty.
 *
 *  NOTICE: The contract should revert when an unrecognized function is called
 */

#define function maxOfArray(uint256[]) payable returns(uint256)

#define macro MAIN() = takes(0) returns(0) {
    // Check for calldata
    0x04 calldatasize lt iszero has_calldata jumpi
        0x00 0x00 revert
    has_calldata:
    
    // Load function selector
    0x00 calldataload 0xE0 shr
    
    // Check if matches maxOfArray selector
    __FUNC_SIG(maxOfArray) eq max_jump jumpi
    
    // Unknown selector, revert
    0x00 0x00 revert
    
    max_jump:
        // Get offset to array data
        0x04 calldataload       // [offset]
        0x04 add                // [array_start_pos]
        
        // Load array length
        dup1 calldataload       // [length, array_start_pos]
        
        // Check if length is 0, revert if so
        dup1 iszero revert_empty jumpi
        
        // Initialize counter to 0
        0x00                    // [counter, length, array_start_pos]
        
        // Load first element as initial max
        dup3 0x20 add calldataload  // [max, counter, length, array_start_pos]
        
        // Increment counter to 1 (already processed first element)
        swap1 0x01 add swap1    // [max, counter(1), length, array_start_pos]
        
        loop:
            // Check if counter >= length
            dup3 dup3 eq end_loop jumpi
            
            // Calculate position of current element: array_start_pos + 32 + (counter * 32)
            dup2 0x20 mul           // [counter*32, max, counter, length, array_start_pos]
            dup5 0x20 add add       // [element_pos, max, counter, length, array_start_pos]
            
            // Load element
            calldataload            // [element, max, counter, length, array_start_pos]
            
            // Compare: if element > max, update max
            dup2 dup2               // [element, max, element, max, counter, length, array_start_pos]
            gt                      // [element > max, element, max, counter, length, array_start_pos]
            
            update_max jumpi
            
            // Max is still larger, pop element
            pop                     // [max, counter, length, array_start_pos]
            continue_loop jump
            
            update_max:
                // Element is larger, replace max
                swap1 pop           // [element(new max), counter, length, array_start_pos]
            
            continue_loop:
                // Increment counter
                swap1               // [counter, max, length, array_start_pos]
                0x01 add            // [counter+1, max, length, array_start_pos]
                swap1               // [max, counter+1, length, array_start_pos]
                
                // Continue loop
                loop jump
        
        end_loop:
            // Clean stack and return max
            swap3 pop pop pop       // [max]
            0x00 mstore
            0x20 0x00 return
        
        revert_empty:
            0x00 0x00 revert
}
