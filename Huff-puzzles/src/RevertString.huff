
/**
 *  REVERT_STRING HUFF EXERCISE
 *
 *
 *  When a transaction is being executed within a smart contract, based on the logic of that contract, it can revert if a preset condition is not met.
 *  They're 2 main ways to revert in solidity, 
 *  - using a string error message e,g (`require(x != 0, "Only values above 0");`)
 *  - reverting with a custom error e.g (`if(x == 0) revert OnlyValuesAbove0();`)
 *
 *  The task is to write within the `MAIN` macro below, huff code that reverts (all the time) with the string error message `Only Huff`
*/


#define macro MAIN() = takes(0) returns(0) {
    // Error(string) ABI encoding:
    // bytes4(keccak256("Error(string)")) = 0x08c379a0
    // Then: offset(32 bytes) + length(32 bytes) + data(32 bytes, padded)
    
    // Byte positions:
    // 0x00-0x03: selector 0x08c379a0 (but we store full 32 bytes)
    // 0x20-0x3f: offset = 0x20
    // 0x40-0x5f: length = 9
    // 0x60-0x7f: "Only Huff" data
    
    // Store selector (shifted left, in first 4 bytes of 32-byte word)
    0x08c379a000000000000000000000000000000000000000000000000000000000
    0x00 mstore
    
    // Store offset to string (0x20 = 32 bytes)
    0x0000000000000000000000000000000000000000000000000000000000000020
    0x20 mstore
    
    // Store string length (9 bytes)
    0x0000000000000000000000000000000000000000000000000000000000000009
    0x40 mstore
    
    // Store string "Only Huff" (9 ASCII characters, left-aligned in 32 bytes)
    // O=0x4f, n=0x6e, l=0x6c, y=0x79, (space)=0x20, H=0x48, u=0x75, f=0x66, f=0x66
    0x4f6e6c7920487566660000000000000000000000000000000000000000000000
    0x60 mstore
    
    // Revert with the data
    // Start at 0x1c (28 bytes in) to skip leading zeros before selector
    // Length is 4 (selector) + 32 (offset) + 32 (length) + 32 (data) = 100 = 0x64
    0x64 0x1c revert
}

