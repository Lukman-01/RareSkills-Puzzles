
/** 
 *  SUM_ARRAY HUFF EXERCISE
 *
 *  
 *  The task is to write within the `MAIN` macro below, write a functionality that takes an array of uint256 as an argument and returns the sum of all the numbers
 *
 *  NOTICE: The contract should revert when an unrecognized function is called
 */

#define function sumArray(uint256[]) payable returns(uint256)


#define macro MAIN() = takes(0) returns(0) {
    // Check for calldata
    0x04 calldatasize lt iszero has_calldata jumpi
        0x00 0x00 revert
    has_calldata:
    
    // Load function selector
    0x00 calldataload 0xE0 shr
    
    // Check if matches sumArray selector
    __FUNC_SIG(sumArray) eq sum_jump jumpi
    
    // Unknown selector, revert
    0x00 0x00 revert
    
    sum_jump:
        // Get offset to array data
        0x04 calldataload
        0x04 add                // [array_start_pos]
        
        // Load array length
        dup1 calldataload       // [length, array_start_pos]
        
        // Initialize sum to 0
        0x00                    // [sum, length, array_start_pos]
        
        // Initialize counter to 0
        0x00                    // [counter, sum, length, array_start_pos]
        
        loop:
            // Check if counter >= length
            dup3 dup2 eq end_loop jumpi
            
            // Calculate position of current element: array_start_pos + 32 + (counter * 32)
            dup1 0x20 mul           // [counter*32, counter, sum, length, array_start_pos]
            dup5 0x20 add add       // [element_pos, counter, sum, length, array_start_pos]
            
            // Load element
            calldataload            // [element, counter, sum, length, array_start_pos]
            
            // Add to sum
            dup3 add                // [new_sum, counter, sum, length, array_start_pos]
            swap2 pop               // [counter, new_sum, length, array_start_pos]
            
            // Increment counter
            0x01 add                // [counter+1, new_sum, length, array_start_pos]
            
            // Continue loop
            loop jump
        
        end_loop:
            // Clean stack and return sum
            pop                     // [sum, length, array_start_pos]
            swap2 pop pop           // [sum]
            0x00 mstore
            0x20 0x00 return
}
